NSExport.prototype.image = function(event,type) 
{ 
	this.__processImage = function()
	{
		this.__externalScriptLoad.html2canvas = true;
		if(!type || (type !== "png" && type !== "jpeg"))
		{
			this.util.warning("NSExport","Image type value was either not valid or not in the correct format.Hence defaulting to png");
			type = "png";
		}
		var imageType = "image/" + type; 
		var divParent = this.__getStructureForImage();
		if(divParent)
		{
			var nsExport = this;
			html2canvas(divParent,{
				onrendered: function(canvas) {		
					//document.body.appendChild(canvas);
					var data = canvas.toDataURL(imageType);
					console.log(data);
					if(!data || data === "data:,")
					{
						nsExport.util.throwNSError("NSExport","Please give table some width and height");
					}
					else
					{
						nsExport.__downloadFile(data,imageType,type);
					}
				}
			});	
		}
		else
		{
			this.util.throwNSError("NSExport","Please add the table inside a parent Element");
		}
	};
	if(!this.__externalScriptLoad.html2canvas)
	{
		this.__includeJavaScriptFile("/JSLib/lib/com/ext/html2canvas/html2canvas.min.js",this.__processImage.bind(this));
	}
	else
	{
		this.__processImage.bind(this)();
	}
};

NSExport.prototype.__downloadFile = function(text,uri,fileType,event) 
{
	if(text && fileType)
	{
		if ("Blob" in window) 
		{
			var fileName = this.__getFileName(fileType);
			if ("msSaveOrOpenBlob" in navigator) 
			{
				var blobObject = null;
				if(text.indexOf("base64") > -1)
				{
					blobObject = this.__dataURItoBlob(text);
				}
				else
				{
					blobObject = new Blob([text], { type: uri});
				}
				navigator.msSaveOrOpenBlob(blobObject,fileName);
			}
			else
			{
				var hrefvalue = null;
				if(text.indexOf("data:") === -1)
				{
					uri = "data:" + uri;
				}
				if(text.indexOf(";base64,") === -1)
				{
					var base64String = ";base64," + window.btoa(window.unescape(encodeURIComponent(text)));
					hrefvalue = uri + base64String;
				}
				else
				{
					hrefvalue = text;
				}
			    var anchor = document.createElement("a");
			    if ("webkitURL" in window) 
			    {
			          // Chrome allows the link to be clicked without actually adding it to the DOM.
			    	//hrefvalue = window.webkitURL.createObjectURL([hrefvalue]);
			    }
			    else
			    {
			    	//hrefvalue = window.URL.createObjectURL([hrefvalue]);
			    	anchor.style.display = 'none';
			        document.body.appendChild(anchor);
			        this.util.addEvent(anchor,"click",function(event){
			    		document.body.removeChild(event.target);
			    	});
			    }
			    anchor.setAttribute("href",hrefvalue);
			    anchor.setAttribute("download",this.__getFileName(fileType));
			    anchor.setAttribute("target","_blank");
			    anchor.innerHTML = "Download File";
			    anchor.click();
			    if(event)
			    {
			    	this.util.preventDefault(event);
			    }
			}
		}
	}
};

NSExport.prototype.__getStructureForImage = function() 
{ 
	var divReturn = null;
	if(this.__grid)
	{
		if(this.__grid.nodeName === "NS-GRID")
		{
			divReturn = this.__grid.getElement(this.__grid.getID() + this.__grid.__OUTER_CONTAINER_ID);
		}
		else
		{
			divReturn = this.__grid.parentElement;
			if(divReturn && divReturn.nodeName === "BODY")
			{
				divReturn = null;
			}
		}
	}
	return divReturn;
};

//taken from http://stackoverflow.com/questions/4998908/convert-data-uri-to-file-then-append-to-formdata
NSExport.prototype.__dataURItoBlob = function(dataURI) 
{
    // convert base64/URLEncoded data component to raw binary data held in a string
    var byteString = null;
    var uintArray = null;
    var mimeString = null;
    if (dataURI.split(',')[0].indexOf('base64') >= 0)
    {
    	 byteString = window.atob(dataURI.split(',')[1]);
    }
    else
    {
    	 byteString = decodeURIComponent(dataURI.split(',')[1]);
    }
    // separate out the mime component
    mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];
    // write the bytes of the string to a typed array
    uintArray = new Uint8Array(byteString.length);
    for (var count = 0; count < byteString.length; count++) 
    {
    	uintArray[count] = byteString.charCodeAt(count);
    }

    return new Blob([uintArray], {type:mimeString});
};


