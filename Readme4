/******************************************************Start of Column Move logic ********************************************************/

nsGrid.__dragDirection = function(event) 
{
    var direction = null;
    if (this.__lastDragEvent.clientX > event.clientX) 
    {
        direction = "left";
    }
    else if (this.__lastDragEvent.clientX < event.clientX) 
    {
        direction = "right";
    }
    return direction;
};

nsGrid.__createDropTargetEvent = function(event,direction) 
{
    // localise x and y to the target component
    var rect = this.__divCenterTableHeaderContainer.getBoundingClientRect();
    var x = event.clientX - rect.left;
    var y = event.clientY - rect.top;
    var dropTargetEvent = {
        event: event,
        x: x,
        y: y,
        direction: direction
    };
    return dropTargetEvent;
};

nsGrid.__onDragging = function(draggingEvent) 
{
	this.lastDraggingEvent = draggingEvent;
    // if moving up or down (ie not left or right) then do nothing
    if (!draggingEvent || !draggingEvent.direction) 
    {
        return;
    }
    var xAdjustedForScroll = this.adjustXForScroll(draggingEvent);
    this.checkCenterForScrolling(xAdjustedForScroll);
    // find out what the correct position is for this column
    //this.checkColIndexAndMove(draggingEvent, xAdjustedForScroll);
};

nsGrid.adjustXForScroll = function (draggingEvent) {
    if(this.__divCenterTableBodyContainer) 
    {
        return draggingEvent.x + this.__divCenterTableBodyContainer.scrollLeft;
    }
    else 
    {
        return draggingEvent.x;
    }
};

nsGrid.checkCenterForScrolling = function (xAdjustedForScroll) 
{
    if (this.__divCenterTableBodyContainer) 
    {
    	console.log("In checkCenterForScrolling");
        // scroll if the mouse has gone outside the grid (or just outside the scrollable part if pinning)
        // putting in 50 buffer, so even if user gets to edge of grid, a scroll will happen
        var firstVisiblePixel = this.__divCenterTableBodyContainer.scrollLeft;
        var lastVisiblePixel = firstVisiblePixel + this.__divCenterTableBodyContainer.clientWidth;
        this.needToMoveLeft = xAdjustedForScroll < (firstVisiblePixel + 50);
        this.needToMoveRight = xAdjustedForScroll > (lastVisiblePixel - 100);
        console.log(xAdjustedForScroll + "," + firstVisiblePixel + "," + this.needToMoveRight);
        if (this.needToMoveLeft || this.needToMoveRight) {
            this.ensureIntervalStarted();
        }
        else {
            this.ensureIntervalCleared();
        }
    }
};

nsGrid.ensureIntervalStarted = function () {
    if (!this.movingIntervalId) {
        this.intervalCount = 0;
        this.failedMoveAttempts = 0;
        this.movingIntervalId = setInterval(this.moveInterval.bind(this), 100);
        if (this.needToMoveLeft) {
            //this.dragAndDropService.setGhostIcon(dragAndDropService_1.DragAndDropService.ICON_LEFT, true);
        }
        else {
            //this.dragAndDropService.setGhostIcon(dragAndDropService_1.DragAndDropService.ICON_RIGHT, true);
        }
    }
};
nsGrid.ensureIntervalCleared = function () {
    if (this.moveInterval) {
        clearInterval(this.movingIntervalId);
        this.movingIntervalId = null;
        //this.dragAndDropService.setGhostIcon(dragAndDropService_1.DragAndDropService.ICON_MOVE);
    }
};

nsGrid.moveInterval = function () {
    var pixelsToMove;
    this.intervalCount++;
    pixelsToMove = 10 + (this.intervalCount * 5);
    if (pixelsToMove > 100) {
        pixelsToMove = 100;
    }
    var pixelsMoved;
    if (this.needToMoveLeft) {
        pixelsMoved = this.scrollHorizontally(-pixelsToMove);
    }
    else if (this.needToMoveRight) {
        pixelsMoved = this.scrollHorizontally(pixelsToMove);
    }
    if (pixelsMoved !== 0) {
        this.__onDragging(this.lastDraggingEvent);
        this.failedMoveAttempts = 0;
    }
    else {
        this.failedMoveAttempts++;
        if (this.failedMoveAttempts > 7) {
            if (this.needToMoveLeft) {
                //this.columnController.setColumnPinned(this.lastDraggingEvent.dragItem, column_1.Column.PINNED_LEFT);
            }
            else {
                //this.columnController.setColumnPinned(this.lastDraggingEvent.dragItem, column_1.Column.PINNED_RIGHT);
            }
            this.nudge();
        }
    }
};

nsGrid.scrollHorizontally = function (pixels) {
    var oldScrollPosition = this.__divCenterTableBodyContainer.scrollLeft;
    this.__divCenterTableBodyContainer.scrollLeft = oldScrollPosition + pixels;
    var newScrollPosition = this.__divCenterTableBodyContainer.scrollLeft;
    return newScrollPosition - oldScrollPosition;
};

nsGrid.nudge = function () {
    if (this.dragging) {
        this.__onDragging(this.__lastDragEvent);
    }
};

nsGrid.__startColumnMove = function(event,target)
{
	if(this.__onGridLine)
	{
		return;
	}
	var objColumn = this.__getColumnObject(target.getAttribute("currentColumnIndex"));
	var columnIndex = this.__getColumnIndexByObject(objColumn);
	if(columnIndex > -1)
	{
		this.__lastDragEvent = event;
		this.dragging = true;
		this.__objColumnDrag = {};
		this.__objColumnDrag.source = target;
		this.__objColumnDrag.objColumn = objColumn;
		this.__objColumnDrag.columnIndex = columnIndex;
		var position = this.util.getEventPosition(event);
		this.__objColumnDrag.dragElement = this.__createCopyItem(target,position);
		this.__objColumnDrag.dragElementAdded = false;
		this.__objColumnDrag.position = position;
		this.__dragColumnMoveRef = this.__dragColumnMoveHandler.bind(this);
		this.__dragColumnEndRef = this.__dragColumnEndHandler.bind(this);
		this.util.addEvent(document,"mousemove",this.__dragColumnMoveRef);
		this.util.addEvent(document,"mouseup",this.__dragColumnEndRef);
	}
};

nsGrid.__dragColumnMoveHandler = function(event)
{
	event = this.util.getEvent(event);
	var direction = this.__dragDirection(event);
	this.__lastDragEvent = event;
	
	var position = this.util.getEventPosition(event);
	var leftOffset = this.__objColumnDrag.position.left - position.left;
    var topOffset = this.__objColumnDrag.position.top - position.top;
    var dragRadius = (leftOffset * leftOffset) + (topOffset * topOffset);
    if(!this.__objColumnDrag.dragElementAdded && dragRadius > this.__MIN_DRAG_OFFSET)
    {
    	document.body.appendChild(this.__objColumnDrag.dragElement);
    	this.__objColumnDrag.dragElementAdded = true;
    }
    var posEvent = this.util.getEventPosition(event);
    this.__objColumnDrag.dragElement.style.left = posEvent.left + "px"; //position.left + "px";
    this.__objColumnDrag.dragElement.style.top = posEvent.top + "px";
    if(this.__objColumnDrag.lastDropTarget)
    {
    	this.util.removeStyleClass(this.__objColumnDrag.lastDropTarget,"nsDottedCell"); 
    	this.__objColumnDrag.lastDropTarget = null;
    }
    var target = this.util.getTarget(event);
    var element = this.util.findParentBySelector(target,"." + this.__CLASS_TABLE_HEADER_DROPPABLE_CELL);
    if(element != this.__objColumnDrag.source)
    {
    	this.util.addStyleClass(element,"nsDottedCell");   
    	this.__objColumnDrag.lastDropTarget = element;
    }
    var draggingEvent = this.__createDropTargetEvent(event,direction);
    this.__onDragging(draggingEvent);
    event.preventDefault();
};

nsGrid.__dragColumnEndHandler = function(event)
{
	this.__lastDragEvent = null;
	this.dragging = false;
	this.ensureIntervalCleared();
	if(this.__objColumnDrag.lastDropTarget)
    {
    	this.util.removeStyleClass(this.__objColumnDrag.lastDropTarget,"nsDottedCell"); 
    	this.__objColumnDrag.lastDropTarget = null;
    }
	this.util.removeEvent(document,"mousemove",this.__dragColumnMoveRef);
	this.__dragColumnMoveRef = null;
	this.util.removeEvent(document,"mouseup",this.__dragColumnEndRef);
	this.__dragColumnEndRef = null;
	if(this.__objColumnDrag.dragElementAdded)
	{
		var position = this.util.getEventPosition(event);
		position.top = position.top + this.__divCenterTableHeaderContainer.scrollTop;
		position.left = position.left + this.__divCenterTableHeaderContainer.scrollLeft;
		var tablePosition = this.util.getOffSet(this.__tblCenterHeader);
		if (position.top < tablePosition.top || position.top > (tablePosition.top + this.__tblCenterHeader.offsetHeight)) 
		{
			this.util.addStyleClass(this.__objColumnDrag.dragElement,"nsGhostHeader");
			var transitionEndCallback = function()
			{
				if(this.__objColumnDrag.dragElement)
				{
					document.body.removeChild(this.__objColumnDrag.dragElement);
					this.__objColumnDrag.dragElement = null;
				}
			};
			var transition = new this.util.transition(this.__objColumnDrag.dragElement,transitionEndCallback.bind(this));
			this.__objColumnDrag.dragElement.style.left = this.__objColumnDrag.position.left + "px"; //position.left + "px";
			this.__objColumnDrag.dragElement.style.top = this.__objColumnDrag.position.top + "px";
		    return;
		}
		var targetIndex = this.__getHeaderColumnByPosition(position);
	    if (targetIndex > -1 && targetIndex != this.__objColumnDrag.columnIndex) 
	    {
	    	this.swapColumns(this.__objColumnDrag.columnIndex,targetIndex);
	    }
	    document.body.removeChild(this.__objColumnDrag.dragElement);
	}
};
