"use strict"; 
function NSSortable(setting) 
{
	this.util = new NSUtil();
	
	this.__id = null;
	this.__setting = setting;
	this.__config = null;
	
	
	this.__documentMouseMoveRef = null;
	this.__documentMouseUpRef = null;
	
	this.__initialize();
}

NSSortable.prototype.remove = function() 
{ 
	if(this.__documentMouseMoveRef)
	{
		this.util.removeEvent(document,"mousemove",this.__documentMouseMoveRef);
		this.__documentMouseMoveRef = null;
	}
	if(!this.__documentMouseUpRef)
	{
		this.util.removeEvent(document,"mouseup",this.__documentMouseUpRef);
		this.__documentMouseUpRef = null;
	}
};

NSSortable.prototype.__initialize = function()
{
	if(this.__setting)
	{
		this.__config = {
				table: this.__setting["table"] || null,
				isSameTableMove: (this.util.isUndefined(this.__setting["isSameTableMove"]) || this.__setting["isSameTableMove"] === null) ? true : Boolean.parse(this.__setting["isSameTableMove"]),
				droppableTable: this.__setting["droppableTable"] || null,
				dropEndHandler: (this.__setting["dropEndHandler"] ? this.util.getFunction(this.__setting["dropEndHandler"]) : null)
		};
		if(this.__config.table)
		{
			if(!this.__documentMouseMoveRef)
			{
				this.__documentMouseMoveRef = this.__documentMouseMoveHandler.bind(this);
				this.util.addEvent(document,"mousemove",this.__documentMouseMoveRef);
			}
			if(!this.__documentMouseUpRef)
			{
				this.__documentMouseUpRef = this.__documentMouseUpHandler.bind(this);
				this.util.addEvent(document,"mouseup",this.__documentMouseUpRef);
			}
			var rows = this.__config.table.tBodies[0].rows;
	        for (var count = 0; count < rows.length; count++) 
	        {
	        	var row = rows[count];
	        	var dragAllowed = true;
	    		if(row.getAttribute("nsDragAllowed"))
	    		{
	    			dragAllowed = Boolean.parse(row.getAttribute("nsDragAllowed"));
	    		}
				if (dragAllowed) 
				{ 
					this.__makeRowDraggable(row);
				}
	        }
		}
	}
};

NSSortable.prototype.__getID = function()
{
	if(!this.__id)
	{
		if(this.__config.table.hasAttribute("id"))
		{
			this.__id = this.__config.table.getAttribute("id");
		}
		else if(this.__config.table.hasAttribute("name"))
		{
			this.__id = this.__config.table.getAttribute("name");
		}
		else
		{
			this.__id = "comp" + this.util.getUniqueId();
		}
	}
	return this.__id;
};

NSSortable.prototype.nsElement = function()
{
	this.util = new NSUtil();
	this.getHeight = function(element) 
	{
		return element[0].getBoundingClientRect().height;
    };
    
    this.getWidth = function(element) 
	{
    	return element[0].getBoundingClientRect().width;
    };
    
    this.getOffset = function(element,scrollableContainer) 
	{
    	var boundingClientRect = element.getBoundingClientRect();
        if (!scrollableContainer) 
        {
        	scrollableContainer = document.documentElement;
        }
        return 
        {
        	width: boundingClientRect.width || element.offsetWidth,height: boundingClientRect.height || element.offsetHeight,
        	top: boundingClientRect.top + (window.pageYOffset || scrollableContainer.scrollTop - scrollableContainer.offsetTop),
        	left: boundingClientRect.left + (window.pageXOffset || scrollableContainer.scrollLeft - scrollableContainer.offsetLeft)
        };
    };
    
    this.getEvent = function(event) 
	{
    	var obj = event;
        if (event.targetTouches !== undefined) 
        {
        	obj = event.targetTouches.item(0);
        } 
        else if (event.originalEvent !== undefined && event.originalEvent.targetTouches !== undefined) 
        {
        	obj = event.originalEvent.targetTouches.item(0);
        }
        return obj;
    };
    
    this.isTouchInvalid = function(event) 
	{
    	var touchInvalid = false;
        if (event.touches !== undefined && event.touches.length > 1) 
        {
          touchInvalid = true;
        } 
        else if (event.originalEvent !== undefined &&
          event.originalEvent.touches !== undefined && event.originalEvent.touches.length > 1) 
        {
          touchInvalid = true;
        }
        return touchInvalid;
    };
    
    this.positionStarted = function(event,target,scrollableContainer) 
	{
    	var pos = {};
        pos.offsetX = event.pageX - this.offset(target, scrollableContainer).left;
        pos.offsetY = event.pageY - this.offset(target, scrollableContainer).top;
        pos.startX = pos.lastX = event.pageX;
        pos.startY = pos.lastY = event.pageY;
        pos.nowX = pos.nowY = pos.distX = pos.distY = pos.dirAx = 0;
        pos.dirX = pos.dirY = pos.lastDirX = pos.lastDirY = pos.distAxX = pos.distAxY = 0;
        return pos;
    };
    
    this.calculatePosition = function(position,event) 
	{
    	 position.lastX = position.nowX;
         position.lastY = position.nowY;

         // mouse position this events
         position.nowX = event.pageX;
         position.nowY = event.pageY;

         // distance mouse moved between events
         position.distX = position.nowX - position.lastX;
         position.distY = position.nowY - position.lastY;

         // direction mouse was moving
         position.lastDirX = position.dirX;
         position.lastDirY = position.dirY;

         // direction mouse is now moving (on both axis)
         position.dirX = position.distX === 0 ? 0 : position.distX > 0 ? 1 : -1;
         position.dirY = position.distY === 0 ? 0 : position.distY > 0 ? 1 : -1;

         // axis mouse is now moving on
         var newAx = Math.abs(position.distX) > Math.abs(position.distY) ? 1 : 0;

         // calc distance moved on this axis (and direction)
         if (position.dirAx !== newAx) 
         {
           position.distAxX = 0;
           position.distAxY = 0;
         } 
         else 
         {
           position.distAxX += Math.abs(position.distX);
           if (position.dirX !== 0 && position.dirX !== position.lastDirX) 
           {
             position.distAxX = 0;
           }

           position.distAxY += Math.abs(position.distY);
           if (position.dirY !== 0 && position.dirY !== position.lastDirY) 
           {
             position.distAxY = 0;
           }
         }
         position.dirAx = newAx;
    };
    
    this.movePosition = function(event,element,position,container,cssPosition,scrollableContainer) 
	{
    	var bounds;
        var useRelative = (cssPosition === 'relative');
        element.x = event.pageX - position.offsetX;
        element.y = event.pageY - position.offsetY;

        if (container) 
        {
          bounds = this.offset(container, scrollableContainer);

          if (useRelative) 
          {
            // reduce positioning by bounds
            element.x -= bounds.left;
            element.y -= bounds.top;

            // reset bounds
            bounds.left = 0;
            bounds.top = 0;
          }

          if (element.x < bounds.left) 
          {
            element.x = bounds.left;
          } 
          else if (element.x >= bounds.width + bounds.left - this.offset(element).width) 
          {
        	  element.x = bounds.width + bounds.left - this.offset(element).width;
          }
          if (element.y < bounds.top) 
          {
            element.y = bounds.top;
          } 
          else if (element.y >= bounds.height + bounds.top - this.offset(element).height) 
          {
        	 element.y = bounds.height + bounds.top - this.offset(element).height;
          }
        }
        element.style.left = element.x + 'px';
        element.style.top = element.y + 'px';
        
        this.calculatePosition(position, event);
    };
    
    this.dragItem = function(item) 
	{
    	var self = this;
    	var canMove = function(itemPosition, targetElement, targetElementOffset) 
    	{
            // return true if targetElement has been changed since last call
            if (this.targetElement !== targetElement) 
            {
              this.targetElement = targetElement;
              this.targetElementOffset = targetElementOffset;
              return true;
            }
            // return true if mouse is moving in the last moving direction of targetElement
            if (itemPosition.dirX * (targetElementOffset.left - this.targetElementOffset.left) > 0 ||
                itemPosition.dirY * (targetElementOffset.top - this.targetElementOffset.top) > 0) {
              this.targetElementOffset = targetElementOffset;
              return true;
            }
            // return false otherwise
            return false;
         };
    };
    
    this.noDrag = function(element) 
	{
    	 return element.hasAttribute("no-drag");
    };
    
    this.findAncestor = function(element,selector) 
	{
    	return this.util.findParentBySelector(element,selector);
    };
};

NSSortable.prototype.nsDragItem = function(setting)
{
	this.util = new NSUtil();
	this.index = item.index();
	this.parent = item.sortableScope;
	this.source = item;
	this.targetElement = null;
	this.targetElementOffset = null;
	this.sourceInfo = {index: item.index(),itemScope: item.itemScope,sortableScope: item.sortableScope};
	this.canMove = function(itemPosition, targetElement, targetElementOffset) {
      // return true if targetElement has been changed since last call
      if (this.targetElement !== targetElement) {
        this.targetElement = targetElement;
        this.targetElementOffset = targetElementOffset;
        return true;
      }
      // return true if mouse is moving in the last moving direction of targetElement
      if (itemPosition.dirX * (targetElementOffset.left - this.targetElementOffset.left) > 0 ||
          itemPosition.dirY * (targetElementOffset.top - this.targetElementOffset.top) > 0) {
        this.targetElementOffset = targetElementOffset;
        return true;
      }
      // return false otherwise
      return false;
    };
    this.moveTo = function (parent, index) 
    {
    	// move the item to a new position
    	this.parent = parent;
    	// if the source item is in the same parent, the target index is after the source index and we're not cloning
    	if (this.isSameParent() && this.source.index() < index && !this.sourceInfo.sortableScope.cloning) 
    	{
    		index = index - 1;
    	}
    	this.index = index;
    };
    this.isSameParent = function () 
    {
    	return this.parent.element === this.sourceInfo.sortableScope.element;
    };
    this.isOrderChanged = function () 
    {
    	return this.index !== this.sourceInfo.index;
    };
    this.eventArgs = function() 
    {
    	return {source: this.sourceInfo,dest: {index: this.index,sortableScope:this.parent}};
    };
    this.apply = function() 
    {
	     if (!this.sourceInfo.sortableScope.cloning) 
	     {
	       // if not cloning, remove the item from the source model.
	       this.sourceInfo.sortableScope.removeItem(this.sourceInfo.index);
	
	        // if the dragged item is not already there, insert the item. This avoids ng-repeat dupes error
	       if (this.parent.options.allowDuplicates || this.parent.modelValue.indexOf(this.source.modelValue) < 0) 
	       {
	          this.parent.insertItem(this.index, this.source.modelValue);
	       }
	     } 
	     else if (!this.parent.options.clone) 
	     { 
	    	  this.parent.insertItem(this.index, angular.copy(this.source.modelValue));
	     }
    };
  };
};
